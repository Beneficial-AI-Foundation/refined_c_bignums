{
  "data": {
    "bignum_add": [
      [
        "binary_sum_within_i32_bounds",
        "partial_sum_complete", 
        "binary_sum_min_bound", 
        "binary_sum_with_carry_bound",
        "binary_add_quot", 
        "initial_partial_sum_correct",
        "partial_sum_step_exact", 
        "update_preserves_binary"
      ],
      "[[rc::parameters(\"a_loc : loc\", \"b_loc : loc\", \"result_loc : loc\", \n                 \"bits_a : {list Z}\", \"bits_b : {list Z}\", \"n : Z\", \"initial_result : {list Z}\")]]\n[[rc::args(\"a_loc @ &own<array<i32, {bits_a `at_type` (int i32)}>>\",\n           \"b_loc @ &own<array<i32, {bits_b `at_type` (int i32)}>>\", \n           \"result_loc @ &own<array<i32, {initial_result `at_type` (int i32)}>>\",\n           \"n @ int<i32>\")]]\n[[rc::requires(\"{length initial_result = Z.to_nat (n + 1)}\")]]\n[[rc::requires(\"{length bits_a = Z.to_nat n}\", \"{length bits_b = Z.to_nat n}\",\n               \"{is_binary bits_a}\", \"{is_binary bits_b}\")]]\n[[rc::requires(\"{n > 0}\", \"{n < max_int i32}\")]]\n[[rc::returns(\"void\")]]\n[[rc::ensures(\"own a_loc : array<i32, {bits_a `at_type` (int i32)}>\")]]\n[[rc::ensures(\"own b_loc : array<i32, {bits_b `at_type` (int i32)}>\")]]\n[[rc::exists(\"final_result : {list Z}\")]]\n[[rc::ensures(\"own result_loc : array<i32, {final_result `at_type` (int i32)}>\")]]\n[[rc::ensures(\"{length final_result = Z.to_nat (n + 1)}\")]]\n[[rc::ensures(\"{is_binary final_result}\")]]\n[[rc::ensures(\"{bits_to_nat final_result = Z.to_nat ((Z.of_nat (bits_to_nat bits_a) + Z.of_nat (bits_to_nat bits_b)) )}\")]]\n[[rc::lemmas(\"binary_sum_within_i32_bounds\",\n             \"partial_sum_complete\", \"binary_sum_min_bound\", \"binary_sum_with_carry_bound\",\n             \"binary_add_quot\", \"initial_partial_sum_correct\",\n             \"partial_sum_step_exact\", \"update_preserves_binary\")]]\n[[rc::tactics(\"all: try solve [eauto using binary_sum_within_i32_bounds | eauto using binary_sum_with_carry_bound | eauto using binary_add_quot].\")]]\n[[rc::tactics(\"all: try solve [eauto using binary_sum_min_bound].\")]]\n[[rc::tactics(\"all: try solve [eauto using initial_partial_sum_correct].\")]]\n[[rc::tactics(\"all: try solve [eapply partial_sum_complete with (i:=i_val) (carry_val:=carry_val) (bits_result:=current_result) (bits_a:=bits_a) (bits_b:=bits_b) (n:=n); eauto].\")]]\n[[rc::tactics(\"all: try solve [eapply update_preserves_binary; eauto].\")]]\nvoid bignum_add(int* a, int* b, int* result, int n) {\n    int carry = 0;\n    \n    [[rc::exists(\"i_val : nat\", \"carry_val : Z\", \"current_result : {list Z}\")]]\n    [[rc::inv_vars(\"i : i_val @ int<i32>\", \"carry : carry_val @ int<i32>\", \n                   \"result : result_loc @ &own<array<i32, {current_result `at_type` (int i32)}>>\")]]\n    [[rc::constraints(\"{0 <= i_val}\", \"{i_val <= Z.to_nat n}\", \"{carry_val = 0 ∨ carry_val = 1}\")]]\n    [[rc::constraints(\"{length current_result = Z.to_nat (n + 1)}\")]]\n    [[rc::constraints(\"{partial_sum_correct i_val carry_val current_result bits_a bits_b}\")]]\n    for (int i = 0; i < n; i++) {\n        int bit_sum = a[i] + b[i] + carry;\n        result[i] = bit_sum % 2;\n        carry = bit_sum / 2;\n    }\n    \n    result[n] = carry;\n}",
      "function"
    ],
    "bits_to_nat": [
      [],
      "Definition bits_to_nat (bits : list Z) : nat :=\n  fold_right (fun b acc => Z.to_nat b + 2 * acc) 0 (rev bits).",
      "definition"
    ],
    "partial_sum_correct": [
      [
        "bits_to_nat"
      ],
      "Definition partial_sum_correct (i : nat) (carry : Z) (bits_result : list Z)\n                              (bits_a bits_b : list Z) :=\n    (bits_to_nat (take i bits_a) + bits_to_nat (take i bits_b)) =\n    bits_to_nat (take i bits_result) + Z.to_nat carry * 2^i.",
      "definition"
    ],
    "is_binary": [
      [],
      "Definition is_binary (bits : list Z) := \n  Forall (fun b => b = 0 ∨ b = 1) bits.",
      "definition"
    ],
    "binary_sum_within_i32_bounds": [
      [
        "is_binary"
      ],
      "Lemma binary_sum_within_i32_bounds (bits_a bits_b : list Z) (i : nat) (y y0 : Z) :\n  is_binary bits_a →\n  is_binary bits_b →\n  bits_a !! i = Some y →\n  bits_b !! i = Some y0 →\n  y + y0 <= max_int i32.\nProof. Admitted.",
      "lemma"
    ],
    "partial_sum_step_exact": [
      [
        "is_binary",
        "partial_sum_correct"
      ],
      "Lemma partial_sum_step_exact (bits_a bits_b : list Z) (n : Z) (initial_result : list Z)\n                            (i_val : nat) (carry_val : Z) (current_result : list Z)\n                            (y y0 y1 : Z) :\n  is_binary bits_a →\n  is_binary bits_b →\n  carry_val = 0 ∨ carry_val = 1 →\n  partial_sum_correct i_val carry_val current_result bits_a bits_b →\n  i_val < n →\n  bits_a !! i_val = Some y →\n  bits_b !! i_val = Some y0 →\n  current_result !! i_val = Some y1 →\n  partial_sum_correct (i_val + 1) ((y + y0 + carry_val) `quot` 2)\n    (<[i_val:=(y + y0 + carry_val) `rem` 2]> current_result) bits_a bits_b.\nProof. Admitted.",
      "lemma"
    ],
    "partial_sum_complete": [
      [
        "partial_sum_correct",
        "bits_to_nat"
      ],
      "Lemma partial_sum_complete (i : nat) (carry_val : Z) (bits_result : list Z)\n                          (bits_a bits_b : list Z) (n : Z) :\n  i ≤ n →\n  ¬ i < n →\n  partial_sum_correct i carry_val bits_result bits_a bits_b →\n  bits_to_nat (<[Z.to_nat n:=carry_val]> bits_result) = Z.to_nat (bits_to_nat bits_a + bits_to_nat bits_b).\nProof. Admitted.",
      "lemma"
    ],
    "binary_sum_min_bound": [
      [
        "is_binary"
      ],
      "Lemma binary_sum_min_bound (bits_a bits_b : list Z) (i : nat) (y y0 : Z) :\n  is_binary bits_a →\n  is_binary bits_b →\n  bits_a !! i = Some y →\n  bits_b !! i = Some y0 →\n  min_int i32 ≤ y + y0.\nProof. Admitted.",
      "lemma"
    ],
    "binary_sum_with_carry_bound": [
      [
        "is_binary"
      ],
      "Lemma binary_sum_with_carry_bound (bits_a bits_b : list Z) (i : nat) (y y0 carry_val : Z) :\n  is_binary bits_a →\n  is_binary bits_b →\n  bits_a !! i = Some y →\n  bits_b !! i = Some y0 →\n  (carry_val = 0 ∨ carry_val = 1) →\n  y + y0 + carry_val ≤ max_int i32.\nProof. Admitted.",
      "lemma"
    ],
    "binary_add_quot": [
      [
        "is_binary"
      ],
      "Lemma binary_add_quot (bits_a bits_b : list Z) (i : nat) (y y0 carry_val : Z) :\n  is_binary bits_a →\n  is_binary bits_b →\n  bits_a !! i = Some y →\n  bits_b !! i = Some y0 →\n  (carry_val = 0 ∨ carry_val = 1) →\n  (y + y0 + carry_val) `quot` 2 = 0 ∨ (y + y0 + carry_val) `quot` 2 = 1.\nProof. Admitted.",
      "lemma"
    ],
    "initial_partial_sum_correct": [
      [
        "is_binary",
        "partial_sum_correct"
      ],
      "Lemma initial_partial_sum_correct :\n  ∀ bits_a bits_b bits_result,\n  is_binary bits_a →\n  is_binary bits_b →\n  partial_sum_correct 0 0 bits_result bits_a bits_b.\nProof. Admitted.",
      "lemma"
    ],
    "update_preserves_binary": [
      [
        "is_binary"
      ],
      "Lemma update_preserves_binary (current_result : list Z) (n : Z) (carry_val : Z) :\n  carry_val = 0 ∨ carry_val = 1 →\n  Z.to_nat n < length current_result →\n  is_binary (<[Z.to_nat n:=carry_val]> current_result).\nProof. Admitted.",
      "lemma"
    ]
  }
}
